<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Einstein Summation Notation in Common Lisp</title>
<meta name="author" content="Bibek Panthi" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="../css/stylesheet.css" />
<link rel="stylesheet" type="text/css" href="../css/braindump.css" />
<script src="../js/counters.js" type="text/javascript"></script>
<script src="../js/URI.js" type="text/javascript"></script>
<script src="../js/pages.js" type="text/javascript"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="./index.html"> UP </a>
 |
 <a accesskey="H" href="../index.html"> HOME </a>
</div><div id="preamble" class="status">
<p class="date">Date: 2020-11-20</p>
</div>
<div id="content" class="content">
<h1 class="title">Einstein Summation Notation in Common Lisp</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#Introduction">1. Introduction</a></li>
<li><a href="#Einsum">2. Einsum</a></li>
<li><a href="#Overview">3. Overview</a></li>
<li><a href="#Index%20Variables%20-%20Dynamic%20Extend">4. Index Variables - Dynamic Extend</a></li>
<li><a href="#Array%20Dimensions">5. Array Dimensions</a></li>
<li><a href="#Allocate%20Result%20array">6. Allocate Result array</a></li>
<li><a href="#Loops">7. Loops</a>
<ul>
<li><a href="#Loop%20Over">7.1. Loop Over</a>
<ul>
<li><a href="#Utilites%20used">7.1.1. Utilites used</a></li>
</ul>
</li>
<li><a href="#Outer%20and%20Inner%20loops">7.2. Outer and Inner loops</a></li>
</ul>
</li>
<li><a href="#Return%20Result">8. Return Result</a></li>
<li><a href="#Lets%20see%20usecases">9. Lets see usecases</a>
<ul>
<li><a href="#Transpose">9.1. Transpose</a></li>
<li><a href="#Outer%20Product">9.2. Outer Product</a>
<ul>
<li><a href="#Lets%20see%20the%20timing.">9.2.1. Lets see the timing.</a></li>
</ul>
</li>
<li><a href="#Transpose%20then%20dot">9.3. Transpose then dot</a></li>
<li><a href="#Sth%20complicated">9.4. Sth complicated</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-Introduction" class="outline-2">
<h2 id="Introduction"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
My target is to be able to write operations on vector, matrices, tensors directly in Einstein summation notation instead of loops.
</p>

<details open><summary><span class='org-details-collapse'>&lt; Collapse code block</span><span class='org-details-expand'>&gt; Expand code block</span></summary>
<div class="org-src-container">
<pre class="src src-lisp"><span class="org-comment-delimiter">;; </span><span class="org-comment">d_i = L_k V^k_i [ 1 - (s^i)^2]</span>
(<span class="org-keyword">loop</span> for i from 0 below (length di) do
  (setf (aref d i)
        (* (- 1 (expt (aref s i) 2))
           (<span class="org-keyword">loop</span> for k from 0 below (array-dimension V 1)
                 summing (* (aref (aref dL/do time) k)
                            (aref V k i))))))
</pre>
</div></details>
<p>
In the end we should be able to replace above expression with:
</p>
<details open><summary><span class='org-details-collapse'>&lt; Collapse code block</span><span class='org-details-expand'>&gt; Expand code block</span></summary>
<div class="org-src-container">
<pre class="src src-lisp">(einsum (ik <span class="org-builtin">:to</span> i)
        <span class="org-builtin">:into</span> d
        (k L) (ki V) (- 1 (expt (i s) 2)))
</pre>
</div></details>

<p>
We sum over the product of given terms such that indices `i' &amp; `k' are reduce to just `i' and the result is stored in `d'. Notice how similar is the new code to the comment in the original code which describes the mathematics.
</p>

<p>
Inside the expressions the indices are associated with tensors using function call notation. These function are purely syntactical and are replaced by corresponding `aref' on the arrays <sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>.
</p>
</div>
</div>
<div id="outline-container-Einsum" class="outline-2">
<h2 id="Einsum"><span class="section-number-2">2.</span> Einsum</h2>
<div class="outline-text-2" id="text-2">
<details open><summary><span class='org-details-collapse'>&lt; Collapse code block</span><span class='org-details-expand'>&gt; Expand code block</span></summary>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defmacro</span> <span class="org-function-name">einsum</span> ((rhs-indices to lhs-indices) <span class="org-type">&amp;rest</span> expr)
  <span class="org-doc">"Expand expressions in Einstein's summation notation to loops"</span>
  (<span class="org-warning">assert</span> (eql to <span class="org-builtin">:to</span>))
  (<span class="org-keyword">if</span> (eql (first expr) <span class="org-builtin">:into</span>)
      (<span class="org-keyword">progn</span>
        (<span class="org-warning">assert</span> (symbolp (second expr)))
        (apply #'einsum% (string rhs-indices) (string lhs-indices) (second expr) (cddr expr)))
      (apply #'einsum% (string rhs-indices) (string lhs-indices) nil expr)))
</pre>
</div></details>

<p>
Inside the `einsum' macro we only handle the syntactic structure and use `einsum%' function for bulk of the source code transformation. Also using function makes for easier debuging experience and allows testing from bottom up approach.
</p>
</div>
</div>
<div id="outline-container-Overview" class="outline-2">
<h2 id="Overview"><span class="section-number-2">3.</span> Overview</h2>
<div class="outline-text-2" id="text-3">
<p>
Let see at the final result to get a general feel of how `einsum' would work.
</p>
<details open><summary><span class='org-details-collapse'>&lt; Collapse code block</span><span class='org-details-expand'>&gt; Expand code block</span></summary>
<div class="org-src-container">
<pre class="src src-lisp">(macroexpand-1 '(einsum (ik <span class="org-builtin">:to</span> i)
                                <span class="org-builtin">:into</span> d
                                (k L) (ki V) (- 1 (expt (i s) 2))))
</pre>
</div></details>

<pre class="example" id="orgcb71440">
(LET ((#:|I-max754| (ARRAY-DIMENSION S 0)) (#:|K-max755| (ARRAY-DIMENSION V 0)))
  (ASSERT (= (ARRAY-DIMENSION S 0) (ARRAY-DIMENSION V 1)))
  (ASSERT (= (ARRAY-DIMENSION V 0) (ARRAY-DIMENSION L 0)))
  (LET ()
    (LOOP FOR #:I756 FROM 0 BELOW #:|I-max754|
          FOR #:|const-expr-758| = (- 1 (EXPT (AREF S #:I756) 2))
          DO (SETF (AREF D #:I756)
                     (* #:|const-expr-758|
                        (LOOP FOR #:K757 FROM 0 BELOW #:|K-max755|
                              FOR #:|const-expr-759| = (* (AREF L #:K757)
                                                          (AREF V #:K757
                                                                #:I756))
                              SUMMING #:|const-expr-759|))))
    D))
T
</pre>

<p>
We can break down the above expanded code into few parts:
</p>
<ul class="org-ul">
<li>first variable to store array dimesions are created</li>
<li>assertions are added to check that the sizes of the arrays match up</li>
<li>a vector with fill pointer is created that would store the result (if an result-array is provided, this vector is displaced to (i.e. points to) that array)</li>
<li>loops over the indices are created. (looping variable are named `-dim-')
<ul class="org-ul">
<li>outer loops are over the output indices (in this example there is a single outer loops)</li>
<li>in the innermost portion of the outer loop a `(setf (aref &#x2026;)' is used to store the sums into the result array</li>
<li>the sums are computed in inner-loops (in this example there is only one inner loop)</li>
<li>expression which can be taken out of the loops are computed outside loops and stored in `const-expr-' variable</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-Index%20Variables%20-%20Dynamic%20Extend" class="outline-2">
<h2 id="Index%20Variables%20-%20Dynamic%20Extend"><span class="section-number-2">4.</span> Index Variables - Dynamic Extend</h2>
<div class="outline-text-2" id="text-4">
<details open><summary><span class='org-details-collapse'>&lt; Collapse code block</span><span class='org-details-expand'>&gt; Expand code block</span></summary>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">einsum%</span> (input-indices output-indices result-array <span class="org-type">&amp;rest</span> expr)
  (<span class="org-keyword">declare</span> (optimize (debug 3)))
  (<span class="org-keyword">let*</span> ((*indices* (map 'list #'identity input-indices))
         (*indices-max* (mapcar (<span class="org-keyword">lambda</span> (i)
                                  (gensym (concatenate 'string (string i) <span class="org-string">"-max"</span>)))
                                *indices*))
         (*indices-vars* (mapcar (<span class="org-keyword">lambda</span> (i) (gensym (string i))) *indices*))
</pre>
</div></details>

<p>
We set the indices, variables to be used in loops  (e.g. `#:|I-dim1252|' <sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup>) and variable to store the dimensions of indices (eg. `#:|I-max1262|')
</p>

<p>
Values that need to shared between functions are stored in special variables<sup><a id="fnr.3" class="footref" href="#fn.3" role="doc-backlink">3</a></sup> and are bound inside the `einsum%' function.
</p>

<p>
A `defparameter' in the top-level of the file makes those variable `special'. Another approach could be to using
`(declare (special &#x2026;))' but I choose the former style for easier testing and debugging.
</p>

<details open><summary><span class='org-details-collapse'>&lt; Collapse code block</span><span class='org-details-expand'>&gt; Expand code block</span></summary>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defparameter</span> <span class="org-variable-name">*indices*</span> nil)
(<span class="org-keyword">defparameter</span> <span class="org-variable-name">*indices-vars*</span> nil)
(<span class="org-keyword">defparameter</span> <span class="org-variable-name">*indices-max*</span> nil)
(<span class="org-keyword">defparameter</span> <span class="org-variable-name">*constant-indices*</span> nil)
</pre>
</div></details>


<details open><summary><span class='org-details-collapse'>&lt; Collapse code block</span><span class='org-details-expand'>&gt; Expand code block</span></summary>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">index-max</span> (index)
  <span class="org-doc">"Returns gensymed variable used to denote dimension of `</span><span class="org-doc"><span class="org-constant">index</span></span><span class="org-doc">'"</span>
  (nth (position index *indices*) *indices-max*))

(<span class="org-keyword">defun</span> <span class="org-function-name">index-var</span> (index)
  <span class="org-doc">"Returns gensymed variable used as looping variable of `</span><span class="org-doc"><span class="org-constant">index</span></span><span class="org-doc">'"</span>
  (nth (position index *indices*) *indices-vars*))

(<span class="org-keyword">defun</span> <span class="org-function-name">index-function?</span> (symbol)
  <span class="org-doc">"Checks if the `</span><span class="org-doc"><span class="org-constant">symbol</span></span><span class="org-doc">' could be name of a indexing function"</span>
  (<span class="org-keyword">loop</span> for char across (symbol-name symbol) do
        (<span class="org-keyword">unless</span> (find char *indices*)
          (<span class="org-keyword">return</span> nil))
        finally (<span class="org-keyword">return</span> t)))
</pre>
</div></details>
</div>
</div>
<div id="outline-container-Array%20Dimensions" class="outline-2">
<h2 id="Array%20Dimensions"><span class="section-number-2">5.</span> Array Dimensions</h2>
<div class="outline-text-2" id="text-5">
<details open><summary><span class='org-details-collapse'>&lt; Collapse code block</span><span class='org-details-expand'>&gt; Expand code block</span></summary>
<div class="org-src-container">
<pre class="src src-lisp" id="einsum-head">(<span class="org-keyword">defun</span> <span class="org-function-name">einsum%</span> (input-indices output-indices result-array <span class="org-type">&amp;rest</span> expr)
  (<span class="org-keyword">declare</span> (optimize (debug 3)))
  (<span class="org-keyword">let*</span> ((*indices* (map 'list #'identity input-indices))
         (*indices-max* (mapcar (<span class="org-keyword">lambda</span> (i)
                                  (gensym (concatenate 'string (string i) <span class="org-string">"-max"</span>)))
                                *indices*))
         (*indices-vars* (mapcar (<span class="org-keyword">lambda</span> (i) (gensym (string i))) *indices*))

         (dimensions (walk-for-dimensions (cons '* expr)))
         (result (<span class="org-keyword">if</span> result-array result-array (gensym <span class="org-string">"result"</span>))))

    <span class="org-comment-delimiter">;; </span><span class="org-comment">assign max-vars to size of indices</span>
    `(<span class="org-keyword">let</span> (,@(<span class="org-keyword">loop</span> for index in *indices*
                   for max-var = (index-max index)
                   for dim = (find index dimensions <span class="org-builtin">:key</span> #'first)
                   collect `(,max-var (array-dimension ,(second dim) ,(third dim)))))

       <span class="org-comment-delimiter">;; </span><span class="org-comment">dimension assertions</span>
       ,@(dimension-assertions dimensions)
</pre>
</div></details>

<p>
`walk-for-dimensions' walks over the given expressinon to find the arrays, their shape and sizes. For example:
</p>

<details open><summary><span class='org-details-collapse'>&lt; Collapse code block</span><span class='org-details-expand'>&gt; Expand code block</span></summary>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">let</span> ((*indices* '(#\I #\K)))
  (walk-for-dimensions '(* (k L) (ki V) (- 1 (expt (j s) 2)))))
</pre>
</div></details>

<pre class="example">
((#\I V 1) (#\K V 0) (#\K L 0))
</pre>


<p>
This return value means that index `i' is the 2nd dimensions of V, index K is the first dimension of V and L.
</p>

<details open><summary><span class='org-details-collapse'>&lt; Collapse code block</span><span class='org-details-expand'>&gt; Expand code block</span></summary>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">walk-for-dimensions</span> (expr <span class="org-type">&amp;optional</span> results)
  <span class="org-doc">"Look at `</span><span class="org-doc"><span class="org-constant">expr</span></span><span class="org-doc">' and find out the which index corresponds to which dimension of which tensor</span>
<span class="org-doc">returns list of (index tensor axis)"</span>
  (<span class="org-keyword">cond</span> ((or (atom expr) (not *indices*)) nil)
        ((and (listp expr)
              (index-function? (first expr))
              (= (length expr) 2)
              (symbolp (second expr)))
         (<span class="org-keyword">loop</span> for char across (symbol-name (first expr))
               for i from 0 do
                 (pushnew (list char (second expr) i)
                          results <span class="org-builtin">:test</span> #'equal)))
        (t (<span class="org-keyword">loop</span> for subexpr in expr do
          (setf results (walk-for-dimensions subexpr results)))))
  results)

(<span class="org-keyword">defun</span> <span class="org-function-name">dimension-assertions</span> (dimensions)
  <span class="org-doc">"return assert forms; `</span><span class="org-doc"><span class="org-constant">dimesions</span></span><span class="org-doc">' is a list of (index tensor axis)"</span>
  (<span class="org-keyword">loop</span> for index in *indices*
        when (&gt; (count index dimensions <span class="org-builtin">:key</span> #'first) 1)
          collect `(<span class="org-warning">assert</span> (= ,@(remove-if #'not
                                           (mapcar (<span class="org-keyword">lambda</span> (dims)
                                                     (<span class="org-keyword">if</span> (eql (first dims) index)
                                                         `(array-dimension ,(second dims)
                                                                           ,(third dims))))
                                                   dimensions))))))

</pre>
</div></details>
</div>
</div>
<div id="outline-container-Allocate%20Result%20array" class="outline-2">
<h2 id="Allocate%20Result%20array"><span class="section-number-2">6.</span> Allocate Result array</h2>
<div class="outline-text-2" id="text-6">
<p>
If the array to store the results (`result-array') is provided then new result array is not created otherwise a new array is allocated with size given by product of the dimensions of the output-indices.
</p>

<details open><summary><span class='org-details-collapse'>&lt; Collapse code block</span><span class='org-details-expand'>&gt; Expand code block</span></summary>
<div class="org-src-container">
<pre class="src src-lisp" id="einsum-result"><span class="org-comment-delimiter">;; </span><span class="org-comment">allocate resulting array or reuse given array</span>
(<span class="org-keyword">let</span> ,(<span class="org-keyword">unless</span> result-array
              `((,result ,(<span class="org-keyword">if</span> output-indices
                             `(make-array (* ,@(map 'list #'index-max output-indices)))))))
</pre>
</div></details>
</div>
</div>
<div id="outline-container-Loops" class="outline-2">
<h2 id="Loops"><span class="section-number-2">7.</span> Loops</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-Loop%20Over" class="outline-3">
<h3 id="Loop%20Over"><span class="section-number-3">7.1.</span> Loop Over</h3>
<div class="outline-text-3" id="text-7-1">
<p>
To write the outer and inner loops with ease, a helper function `loop-over' is defined as follows:
</p>
<details open><summary><span class='org-details-collapse'>&lt; Collapse code block</span><span class='org-details-expand'>&gt; Expand code block</span></summary>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">loop-over%</span> (index expr then-function constant-product)
  (<span class="org-keyword">let</span> ((*constant-indices* (cons index *constant-indices*)))
    (<span class="org-keyword">multiple-value-bind</span> (const-expr remaining-expr) (extract-constant-expr expr)
      (<span class="org-keyword">if</span> const-expr
          (<span class="org-keyword">let</span> ((var (gensym <span class="org-string">"const-expr-"</span>)))
            `(<span class="org-keyword">loop</span> for ,(index-var index) from 0 below ,(index-max index)
                   for ,var = ,(<span class="org-keyword">if</span> constant-product
                                   (expand-arefs `(* ,@const-expr ,constant-product))
                                   (<span class="org-keyword">if</span> (= (length const-expr) 1)
                                       (expand-arefs (first const-expr))
                                       (expand-arefs `(* ,@const-expr))))
                   ,@(funcall then-function remaining-expr var)))
          `(<span class="org-keyword">loop</span> for ,(index-var index) from 0 below ,(index-max index)
                 ,@(funcall then-function remaining-expr constant-product))))))

(<span class="org-keyword">defun</span> <span class="org-function-name">loop-over</span> (index <span class="org-type">&amp;key</span> checking-constants-in then with-constant)
  <span class="org-doc">"Return a loop form taking care of any expression in `</span><span class="org-doc"><span class="org-constant">checking-constants-in</span></span><span class="org-doc">'</span>
<span class="org-doc"> that can be taken out of the loop</span>
<span class="org-doc"> (loop for index-var from 0 below index-max</span>
<span class="org-doc">       for new-constant = (* with-constant ...)</span>
<span class="org-doc">     ,@(then remaining-expr new-constant)"</span>
  (loop-over% index checking-constants-in then with-constant))

</pre>
</div></details>

<p>
As an example see this:
</p>
<details open><summary><span class='org-details-collapse'>&lt; Collapse code block</span><span class='org-details-expand'>&gt; Expand code block</span></summary>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">let*</span> ((input-indices <span class="org-string">"IK"</span>)
       (*indices* (map 'list #'identity input-indices))
       (*indices-max* (mapcar (<span class="org-keyword">lambda</span> (i)
                                (gensym (concatenate 'string (string i) <span class="org-string">"-max"</span>)))
                              *indices*))
       (*indices-vars* (mapcar (<span class="org-keyword">lambda</span> (i) (gensym (string i))) *indices*)))
  (loop-over #\I
             <span class="org-builtin">:checking-constants-in</span> '((k L) (ki V) (- 1 (expt (i s) 2)))
             <span class="org-builtin">:then</span> (<span class="org-keyword">lambda</span> (remaining-expr const)
                     `(<span class="org-keyword">do</span> (print ,remaining-expr ,const)))
             <span class="org-builtin">:with-constant</span> nil))
</pre>
</div></details>

<pre class="example">
(LOOP FOR #:|I-dim1312| FROM 0 BELOW #:|I-max1313|
      FOR #:|const-expr-1311| = (- 1 (EXPT (AREF S #:|I-dim1314|) 2))
      DO (PRINT ((K L) (KI V)) #:|const-expr-1311|))
</pre>


<p>
`loop-over' was smart enough to identify that the expression `(- 1 (EXPT (AREF S #:|I-dim1314|) 2))' is constant for given `i' so it stored that in a variable name `#:|const-expr-1311|' and passed the remaining expressions and the name of this variable to the `:then' function.
</p>

<p>
In this `loop-over' function few other small functions are used that perform small and easy tasks.
</p>
</div>
<div id="outline-container-Utilites%20used" class="outline-4">
<h4 id="Utilites%20used"><span class="section-number-4">7.1.1.</span> Utilites used</h4>
<div class="outline-text-4" id="text-7-1-1">
<details open><summary><span class='org-details-collapse'>&lt; Collapse code block</span><span class='org-details-expand'>&gt; Expand code block</span></summary>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">expand-arefs</span> (expr)
  <span class="org-doc">"Repalce indexing functions with aref in the expression `</span><span class="org-doc"><span class="org-constant">expr</span></span><span class="org-doc">'"</span>
  (<span class="org-keyword">cond</span> ((atom expr)
         expr)
        ((and (listp expr)
              (index-function? (first expr))
              (= (length expr) 2))
         `(aref ,(second expr) ,@(<span class="org-keyword">loop</span> for index across (symbol-name (first expr))
                                       collect (index-var index))))
        ((listp expr)
         (mapcar (<span class="org-keyword">lambda</span> (e)
                   (expand-arefs e))
                 expr))
        (t expr)))

(<span class="org-keyword">defun</span> <span class="org-function-name">constant-expr?</span> (e)
  <span class="org-doc">"Returns true if expression `</span><span class="org-doc"><span class="org-constant">e</span></span><span class="org-doc">' is constant when indices in `</span><span class="org-doc"><span class="org-constant">*constant-indices*</span></span><span class="org-doc">' are given"</span>
  (<span class="org-keyword">cond</span> ((atom e) t)
        ((and (listp e)
              (index-function? (first e)))
         (<span class="org-keyword">loop</span> for i across (symbol-name (first e)) do
           (<span class="org-keyword">if</span> (not (find i *constant-indices*))
               (<span class="org-keyword">return</span> nil))
               finally (<span class="org-keyword">return</span> t)))
        ((listp e)
         (every (<span class="org-keyword">lambda</span> (e)
                  (constant-expr? e))
                (rest e)))
        (t t)))

(<span class="org-keyword">defun</span> <span class="org-function-name">extract-constant-expr</span> (expr)
  <span class="org-doc">"Return constant and non-constant parts in `</span><span class="org-doc"><span class="org-constant">expr</span></span><span class="org-doc">' under given `</span><span class="org-doc"><span class="org-constant">*constant-indices*</span></span><span class="org-doc">'"</span>
  (<span class="org-keyword">let*</span> ((non-constant-expr (remove-if (<span class="org-keyword">lambda</span> (e)
                                         (constant-expr? e))
                                       expr))
         (constant-expr (set-difference expr non-constant-expr)))
    (values constant-expr non-constant-expr)))
</pre>
</div></details>


<p>
An exmple of `extract-constant-expr' in action:
</p>
<details open><summary><span class='org-details-collapse'>&lt; Collapse code block</span><span class='org-details-expand'>&gt; Expand code block</span></summary>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">let</span> ((*indices* '(#\I #\K))
      (*constant-indices* '(#\I)))
  (extract-constant-expr '((k L) (ki V) (- 1 (expt (i s) 2)))))
</pre>
</div></details>
<pre class="example">
((- 1 (EXPT (I S) 2)))
((K L) (KI V))
</pre>


<p>
An example of `expand-arefs' in action
</p>
<details open><summary><span class='org-details-collapse'>&lt; Collapse code block</span><span class='org-details-expand'>&gt; Expand code block</span></summary>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">let</span> ((*indices* '(#\I #\K)))
    (expand-arefs '(* (k L) (ki V) (- 1 (expt (i s) 2)))))
</pre>
</div></details>

<pre class="example">
(* (AREF L #:|K-dim1394|) (AREF V #:|K-dim1395| #:|I-dim1396|)
   (- 1 (EXPT (AREF S #:|I-dim1397|) 2)))
</pre>
</div>
</div>
</div>
<div id="outline-container-Outer%20and%20Inner%20loops" class="outline-3">
<h3 id="Outer%20and%20Inner%20loops"><span class="section-number-3">7.2.</span> Outer and Inner loops</h3>
<div class="outline-text-3" id="text-7-2">
<p>
Now that we have the convenient loop-over function we can use it to generate the outer and inner loops inside `einsum%'
</p>

<details open><summary><span class='org-details-collapse'>&lt; Collapse code block</span><span class='org-details-expand'>&gt; Expand code block</span></summary>
<div class="org-src-container">
<pre class="src src-lisp" id="einsum-loops"><span class="org-comment-delimiter">;; </span><span class="org-comment">now loop!! :)</span>
,(<span class="org-keyword">labels</span> ((outer-loop (indices expr const)
            (loop-over
             (first indices)
             <span class="org-builtin">:with-constant</span> const
             <span class="org-builtin">:checking-constants-in</span> expr
             <span class="org-builtin">:then</span>
             (<span class="org-keyword">lambda</span> (remaining-expr const)
               (<span class="org-keyword">if</span> (&gt; (length indices) 1)
                   `(<span class="org-keyword">do</span> ,(outer-loop (rest indices)
                                     remaining-expr
                                     const))
                   (<span class="org-keyword">cond</span>
                     ((and const remaining-expr)
                      `(<span class="org-keyword">do</span> (setf (aref ,result ,@(map 'list #'index-var output-indices))
                                 (* ,const ,(inner-loop remaining-expr)))))
                     (remaining-expr
                      `(<span class="org-keyword">do</span> (setf (aref ,result ,@(map 'list #'index-var output-indices))
                                 ,(inner-loop remaining-expr))))
                     (const
                      `(<span class="org-keyword">do</span> (setf (aref ,result ,@(map 'list #'index-var output-indices))
                                 ,const))))))))

          (inner-loop% (indices expr const)
            (loop-over
             (first indices)
             <span class="org-builtin">:checking-constants-in</span> expr
             <span class="org-builtin">:with-constant</span> const
             <span class="org-builtin">:then</span>
             (<span class="org-keyword">lambda</span> (remaining-expr const)
               (<span class="org-keyword">if</span> (&gt; (length indices) 1)
                   (<span class="org-keyword">if</span> const
                       `(summing (* ,const ,(inner-loop% (rest indices)
                                                         remaining-expr nil)))
                       `(summing ,(inner-loop% (rest indices)
                                               remaining-expr nil)))
                   (<span class="org-keyword">cond</span>
                     ((and const remaining-expr)
                      `(summing (* ,const ,(expand-arefs `(* ,@remaining-expr)))))
                     (remaining-expr
                      `(summing ,(expand-arefs `(* ,@remaining-expr))))
                     (const
                      `(summing ,const)))))))

          (inner-loop (expr)
            (inner-loop% (set-difference *indices* (map 'list #'identity output-indices))
                         expr nil)))
   (outer-loop (map 'list #'identity output-indices)
               expr
               nil))
</pre>
</div></details>

<p>
The `outer-loop' recursive create a loop form for each outer index. In the `:then' argument if the length of outer indices is greated that 1 i.e. when some outer loops are still to be created `outer-loop' recursively calls itself. Otherwise, it returns a `do' clause with a `(setf (aref result-array indices&#x2026;) sums)' operation and  calls `inner-loop' to calculate the sums.
</p>

<p>
The `inner-loop' computes the indices that need to be summed over (which is the set difference of all indices with the output-indices). Then calls `inner-loop%' which, similar to how `outer-loop' function operates, creates the inner loops recursively summing the product till the end.
</p>
</div>
</div>
</div>
<div id="outline-container-Return%20Result" class="outline-2">
<h2 id="Return%20Result"><span class="section-number-2">8.</span> Return Result</h2>
<div class="outline-text-2" id="text-8">
<p>
Finally the resulting array is returned.
</p>
<details open><summary><span class='org-details-collapse'>&lt; Collapse code block</span><span class='org-details-expand'>&gt; Expand code block</span></summary>
<div class="org-src-container">
<pre class="src src-lisp" id="einsum-output"><span class="org-comment-delimiter">;; </span><span class="org-comment">return the results</span>
,(or result-array result)))))
</pre>
</div></details>

<p>
Stiching all the pieces together we have the `einsum%' function:
</p>

<details open><summary><span class='org-details-collapse'>&lt; Collapse code block</span><span class='org-details-expand'>&gt; Expand code block</span></summary>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">einsum%</span> (input-indices output-indices result-array <span class="org-type">&amp;rest</span> expr)
  (<span class="org-keyword">declare</span> (optimize (debug 3)))
  (<span class="org-keyword">let*</span> ((*indices* (map 'list #'identity input-indices))
         (*indices-max* (mapcar (<span class="org-keyword">lambda</span> (i) (gensym (concatenate 'string (string i) <span class="org-string">"-max"</span>))) *indices*))
         (*indices-vars* (mapcar (<span class="org-keyword">lambda</span> (i) (gensym (string i))) *indices*))

         (dimensions (walk-for-dimensions (cons '* expr)))
         (result (<span class="org-keyword">if</span> result-array result-array (gensym <span class="org-string">"result"</span>))))

    <span class="org-comment-delimiter">;; </span><span class="org-comment">assign max-vars to size of indices</span>
    `(<span class="org-keyword">let</span> (,@(<span class="org-keyword">loop</span> for index in *indices*
                   for max-var = (index-max index)
                   for dim = (find index dimensions <span class="org-builtin">:key</span> #'first)
                   collect `(,max-var (array-dimension ,(second dim) ,(third dim)))))

       <span class="org-comment-delimiter">;; </span><span class="org-comment">dimension assertions</span>
       ,@(dimension-assertions dimensions)

       <span class="org-comment-delimiter">;; </span><span class="org-comment">allocate resulting array or reuse given array</span>
       (<span class="org-keyword">let</span> ,(<span class="org-keyword">unless</span> result-array
               `((,result ,(<span class="org-keyword">if</span> output-indices
                               `(make-array (* ,@(map 'list #'index-max output-indices)))))))
         <span class="org-comment-delimiter">;; </span><span class="org-comment">now loop!! :)</span>
         ,(<span class="org-keyword">labels</span> ((outer-loop (indices expr const)
                     (loop-over
                      (first indices)
                      <span class="org-builtin">:with-constant</span> const
                      <span class="org-builtin">:checking-constants-in</span> expr
                      <span class="org-builtin">:then</span>
                      (<span class="org-keyword">lambda</span> (remaining-expr const)
                        (<span class="org-keyword">if</span> (&gt; (length indices) 1)
                            `(<span class="org-keyword">do</span> ,(outer-loop (rest indices)
                                              remaining-expr
                                              const))
                            (<span class="org-keyword">cond</span>
                              ((and const remaining-expr)
                               `(<span class="org-keyword">do</span> (setf (aref ,result ,@(map 'list #'index-var output-indices))
                                          (* ,const ,(inner-loop remaining-expr)))))
                              (remaining-expr
                               `(<span class="org-keyword">do</span> (setf (aref ,result ,@(map 'list #'index-var output-indices))
                                          ,(inner-loop remaining-expr))))
                              (const
                               `(<span class="org-keyword">do</span> (setf (aref ,result ,@(map 'list #'index-var output-indices))
                                          ,const))))))))

                   (inner-loop% (indices expr const)
                     (loop-over
                      (first indices)
                      <span class="org-builtin">:checking-constants-in</span> expr
                      <span class="org-builtin">:with-constant</span> const
                      <span class="org-builtin">:then</span>
                      (<span class="org-keyword">lambda</span> (remaining-expr const)
                        (<span class="org-keyword">if</span> (&gt; (length indices) 1)
                            (<span class="org-keyword">if</span> const
                                `(summing (* ,const ,(inner-loop% (rest indices)
                                                                  remaining-expr nil)))
                                `(summing ,(inner-loop% (rest indices)
                                                        remaining-expr nil)))
                            (<span class="org-keyword">cond</span>
                              ((and const remaining-expr)
                               `(summing (* ,const ,(expand-arefs `(* ,@remaining-expr)))))
                              (remaining-expr
                               `(summing ,(expand-arefs `(* ,@remaining-expr))))
                              (const
                               `(summing ,const)))))))

                   (inner-loop (expr)
                     (inner-loop% (set-difference *indices* (map 'list #'identity output-indices))
                                  expr nil)))
            (outer-loop (map 'list #'identity output-indices)
                        expr
                        nil))
         <span class="org-comment-delimiter">;; </span><span class="org-comment">return the results</span>
         ,(or result-array result)))))
</pre>
</div></details>
</div>
</div>
<div id="outline-container-Lets%20see%20usecases" class="outline-2">
<h2 id="Lets%20see%20usecases"><span class="section-number-2">9.</span> Lets see usecases</h2>
<div class="outline-text-2" id="text-9">
<p>
For use in following examples lets define a matrix and two vector
</p>
<details open><summary><span class='org-details-collapse'>&lt; Collapse code block</span><span class='org-details-expand'>&gt; Expand code block</span></summary>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defparameter</span> <span class="org-variable-name">M</span> #2A((1 2 3) (4 5 6)))
(<span class="org-keyword">defparameter</span> <span class="org-variable-name">V</span> (vector 10 2.2 3e3))
(<span class="org-keyword">defparameter</span> <span class="org-variable-name">U</span> (vector 9 4))
</pre>
</div></details>
</div>
<div id="outline-container-Transpose" class="outline-3">
<h3 id="Transpose"><span class="section-number-3">9.1.</span> Transpose</h3>
<div class="outline-text-3" id="text-9-1">
<details open><summary><span class='org-details-collapse'>&lt; Collapse code block</span><span class='org-details-expand'>&gt; Expand code block</span></summary>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">transpose</span> (matrix)
  (<span class="org-keyword">destructuring-bind</span> (m n) (array-dimensions matrix)
    (<span class="org-keyword">let</span> ((new-matrix (make-array (list n m))))
      (<span class="org-keyword">loop</span> for i from 0 below m do
        (<span class="org-keyword">loop</span> for j from 0 below n do
          (setf (aref new-matrix j i)
                (aref matrix i j))))
      new-matrix)))

(transpose M)
</pre>
</div></details>

<pre class="example">
#2A((1 4) (2 5) (3 6))
</pre>


<p>
Equivalent einsum expression
</p>
<details open><summary><span class='org-details-collapse'>&lt; Collapse code block</span><span class='org-details-expand'>&gt; Expand code block</span></summary>
<div class="org-src-container">
<pre class="src src-lisp">(einsum (ij <span class="org-builtin">:to</span> ji) (ij M))
</pre>
</div></details>

<pre class="example">
#2A((1 4) (2 5) (3 6))
</pre>
</div>
</div>
<div id="outline-container-Outer%20Product" class="outline-3">
<h3 id="Outer%20Product"><span class="section-number-3">9.2.</span> Outer Product</h3>
<div class="outline-text-3" id="text-9-2">
<details open><summary><span class='org-details-collapse'>&lt; Collapse code block</span><span class='org-details-expand'>&gt; Expand code block</span></summary>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">incf-outer-product</span> (place vec-a vec-b)
  <span class="org-doc">"Add the outer product of `</span><span class="org-doc"><span class="org-constant">vec-a</span></span><span class="org-doc">' and `</span><span class="org-doc"><span class="org-constant">vec-b</span></span><span class="org-doc">' into `</span><span class="org-doc"><span class="org-constant">place</span></span><span class="org-doc">'"</span>
  (<span class="org-keyword">let</span> ((n (array-dimension place 0))
        (m (array-dimension place 1)))
    (<span class="org-warning">assert</span> (= n (length vec-a)))
    (<span class="org-warning">assert</span> (= m (length vec-b)))
    (<span class="org-keyword">loop</span> for i from 0 below n do
      (<span class="org-keyword">loop</span> for j from 0 below m do
        (incf (aref place i j)
              (* (aref vec-a i)
                 (aref vec-b j)))))
    place))

<span class="org-comment-delimiter">;; </span><span class="org-comment">M^i_j += U^i V_j</span>
(<span class="org-keyword">let</span> ((M (make-array '(2 3) <span class="org-builtin">:initial-contents</span> '((1 2 3) (4 5 6)))))
  (incf-outer-product M
                      U V))
</pre>
</div></details>

<pre class="example">
#2A((91 21.800001 27003.0) (44 13.8 12006.0))
</pre>


<p>
Equivalent einsum expression:
</p>
<details open><summary><span class='org-details-collapse'>&lt; Collapse code block</span><span class='org-details-expand'>&gt; Expand code block</span></summary>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">let</span> ((M (make-array '(2 3) <span class="org-builtin">:initial-contents</span> '((1 2 3) (4 5 6)))))
  (einsum (ij <span class="org-builtin">:to</span> ij) <span class="org-builtin">:into</span> M
          (+ (ij M) (* (i U) (j V)))))
</pre>
</div></details>

<pre class="example">
#2A((91 21.800001 27003.0) (44 13.8 12006.0))
</pre>


<p>
Lets see the code generated by einsum:
</p>
<details open><summary><span class='org-details-collapse'>&lt; Collapse code block</span><span class='org-details-expand'>&gt; Expand code block</span></summary>
<div class="org-src-container">
<pre class="src src-lisp">(macroexpand '(einsum (ij <span class="org-builtin">:to</span> ij) <span class="org-builtin">:into</span> M
               (+ (ij M) (* (i U) (j V)))))
</pre>
</div></details>

<pre class="example" id="org7efa6ae">
(LET ((#:|I-max730| (ARRAY-DIMENSION U 0)) (#:|J-max731| (ARRAY-DIMENSION V 0)))
  (ASSERT (= (ARRAY-DIMENSION U 0) (ARRAY-DIMENSION M 0)))
  (ASSERT (= (ARRAY-DIMENSION V 0) (ARRAY-DIMENSION M 1)))
  (LET ()
    (LOOP FOR #:I732 FROM 0 BELOW #:|I-max730|
          DO (LOOP FOR #:J733 FROM 0 BELOW #:|J-max731|
                   FOR #:|const-expr-734| = (+ (AREF M #:I732 #:J733)
                                               (* (AREF U #:I732)
                                                  (AREF V #:J733)))
                   DO (SETF (AREF M #:I732 #:J733) #:|const-expr-734|)))
    M))
T
</pre>

<p>
Both the handwritten code and generated code are similar.
</p>
</div>
<div id="outline-container-Lets%20see%20the%20timing." class="outline-4">
<h4 id="Lets%20see%20the%20timing."><span class="section-number-4">9.2.1.</span> Lets see the timing.</h4>
<div class="outline-text-4" id="text-9-2-1">
<details open><summary><span class='org-details-collapse'>&lt; Collapse code block</span><span class='org-details-expand'>&gt; Expand code block</span></summary>
<div class="org-src-container">
<pre class="src src-lisp">(time (<span class="org-keyword">let</span> ((M (make-array '(2 3) <span class="org-builtin">:initial-contents</span> '((1 2 3) (4 5 6)))))
                 (<span class="org-keyword">loop</span> repeat 10000000 do
                       (incf-outer-product M U V))
                 M))
</pre>
</div></details>
<details open><summary><span class='org-details-collapse'>&lt; Collapse code block</span><span class='org-details-expand'>&gt; Expand code block</span></summary>
<div class="org-src-container">
<pre class="src src-example">Evaluation took:
  2.090 seconds of real time
  2.088960 seconds of total run time (2.088960 user, 0.000000 system)
  99.95% CPU
  4,814,051,628 processor cycles
  0 bytes consed

#2A((900000001 1.7338182e8 2.9209824e11) (400000004 8.1764024e7 1.046401e11))
</pre>
</div></details>

<p>
einsum:
</p>
<details open><summary><span class='org-details-collapse'>&lt; Collapse code block</span><span class='org-details-expand'>&gt; Expand code block</span></summary>
<div class="org-src-container">
<pre class="src src-lisp">(time (<span class="org-keyword">let</span> ((M (make-array '(2 3) <span class="org-builtin">:initial-contents</span> '((1 2 3) (4 5 6)))))
               (<span class="org-keyword">loop</span> repeat 10000000 do
                 (einsum (ij <span class="org-builtin">:to</span> ij) <span class="org-builtin">:into</span> M
                         (+ (ij M) (* (i U) (j V)))))
               M))
</pre>
</div></details>

<details open><summary><span class='org-details-collapse'>&lt; Collapse code block</span><span class='org-details-expand'>&gt; Expand code block</span></summary>
<div class="org-src-container">
<pre class="src src-example">Evaluation took:
  2.020 seconds of real time
  2.023754 seconds of total run time (2.023754 user, 0.000000 system)
  100.20% CPU
  4,663,633,418 processor cycles
  0 bytes consed

#2A((900000001 1.7338182e8 2.9209824e11) (400000004 8.1764024e7 1.046401e11))
</pre>
</div></details>
</div>
</div>
</div>
<div id="outline-container-Transpose%20then%20dot" class="outline-3">
<h3 id="Transpose%20then%20dot"><span class="section-number-3">9.3.</span> Transpose then dot</h3>
<div class="outline-text-3" id="text-9-3">
<details open><summary><span class='org-details-collapse'>&lt; Collapse code block</span><span class='org-details-expand'>&gt; Expand code block</span></summary>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">matrix-T-dot-vector</span> (matrix vector)
  <span class="org-doc">"Multiply transpose of `</span><span class="org-doc"><span class="org-constant">matrix</span></span><span class="org-doc">' with `</span><span class="org-doc"><span class="org-constant">vector</span></span><span class="org-doc">'"</span>
  (<span class="org-keyword">destructuring-bind</span> (m n) (array-dimensions matrix)
    (<span class="org-warning">assert</span> (= m (length vector)))
    (<span class="org-keyword">let</span> ((result (make-array n)))
      (<span class="org-keyword">loop</span> for j from 0 below n do
        (setf (aref result j)
              (<span class="org-keyword">loop</span> for i from 0 below m
                    summing (* (aref matrix i j)
                               (aref vector i)))))
      result)))

(matrix-T-dot-vector M U)
</pre>
</div></details>

<pre class="example">
#(25 38 51)
</pre>


<details open><summary><span class='org-details-collapse'>&lt; Collapse code block</span><span class='org-details-expand'>&gt; Expand code block</span></summary>
<div class="org-src-container">
<pre class="src src-lisp">(einsum (ij <span class="org-builtin">:to</span> j)
      (ij M) (i U))
</pre>
</div></details>

<pre class="example">
#(25 38 51)
</pre>
</div>
</div>
<div id="outline-container-Sth%20complicated" class="outline-3">
<h3 id="Sth%20complicated"><span class="section-number-3">9.4.</span> Sth complicated</h3>
<div class="outline-text-3" id="text-9-4">
<details open><summary><span class='org-details-collapse'>&lt; Collapse code block</span><span class='org-details-expand'>&gt; Expand code block</span></summary>
<div class="org-src-container">
<pre class="src src-lisp"><span class="org-comment-delimiter">;; </span><span class="org-comment">d_i = d_m,prev W^m_i [ (1 - (s^i)^2)]</span>
(<span class="org-keyword">let</span> ((d (vector 1 2 3))
      (s (vector 9 8 4))
      (W #2A((1 2 3) (3 4 5) (5 6 7))))

  (map-into d
            (<span class="org-keyword">lambda</span> (dW_i s^i)
              (* dW_i (- 1 (expt s^i 2))))
            (matrix-t-dot-vector W d)
            s))
</pre>
</div></details>

<pre class="example">
#(-1760 -1764 -510)
</pre>


<details open><summary><span class='org-details-collapse'>&lt; Collapse code block</span><span class='org-details-expand'>&gt; Expand code block</span></summary>
<div class="org-src-container">
<pre class="src src-lisp"><span class="org-comment-delimiter">;; </span><span class="org-comment">d_m = d_m,prev W^m_i [ (1 - (s^i)^2)]</span>
(<span class="org-keyword">let</span> ((d (vector 1 2 3))
      (s (vector 9 8 4))
      (W #2A((1 2 3) (3 4 5) (5 6 7))))

  (einsum (im <span class="org-builtin">:to</span> i)
          (* (m d) (mi W) (- 1 (expt (i s) 2)))))
</pre>
</div></details>

<pre class="example">
#(-1760 -1764 -510)
</pre>


<p>
Notice how the einsum expression is similar to the mathematical notation given in the comment.
</p>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Array in Common Lisp can be multi-dimensional. So in mathematical terms they can be vectors, matrices, or  n-order tensors.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Yes! These are variable names (i.e. symbols). (They are randomly created (using `gensym') during macroexpansion so that their names don't clash with other variables) (Also since they are randomly generated, the exact number at the end may not match within this document)
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Special Variables are global variabes with dynamic extend. i.e. they can be assessed inside the other function without the need to be passed along with the function.
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<hr/>You can send your feedback, queries <a href="mailto:bpanthi977@gmail.com?subject=Feedback: Einstein Summation Notation in Common Lisp">here</a><span id="visits"></span><span id="claps"></span><div id="claps-message"></div><a href="https://bpanthi977.github.io/braindump/data/rss.xml"><img src="https://bpanthi977.github.io/braindump/data/rss.png" /></a>
</div>
</body>
</html>
